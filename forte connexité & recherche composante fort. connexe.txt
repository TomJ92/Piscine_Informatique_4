bool** Graph::algo_forte_connexite()
{
    int nb_compos=0; ///Nombre de composantes fortement connexes
    bool* marques=new bool[m_ordre]; ///Déclaration du tableau de booléens qui dit si un sommet a été traité ou pas
    bool** compos_connexes; ///Tableau qui détermine les composantes fortement connexes.
    compos_connexes=new bool*[m_ordre]; ///1ere allocation de mémoire
    for(int i=0; i<m_ordre; i++) ///2ème allocation de mémoire
        compos_connexes[i]=new bool[m_ordre];
    for(int i=0; i<m_ordre; i++) ///Initialisation des tableaux
    {
        marques[i]=false;
        for(int j=0; j<m_ordre; j++)
            compos_connexes[i][j]=false;
    }
    for(int i=0; i<m_ordre; i++) ///Pour chaque sommet i du graphe
    {
        if(!marques[i]) ///Si il n'a pas été traité
        {
            marques[i]=true; ///On le marque
            compos_connexes[i]=recherche_cmp(i); ///On cherche si le sommet fait partie d'une composante fortement connexe
            for(int j=0; j<m_ordre; j++) ///Pour chaque sommet j du graphe
            {
                if(compos_connexes[i][j] && !marques[j]) ///Si i et j font partie d'une composante fortement connexe et que j n'a pas été traité
                {
                    marques[j]=true; ///On le marque
                }
            }
        }
    }
    std::cout << std::endl;
    for(int i=0; i<m_ordre; i++) ///Affichage du tableau de booléens pour les composantes fortement connexes
    {
        for(int j=0; j<m_ordre; j++)
        {
            if(compos_connexes[i][j]) ///On affiche 1 si la valeur est true, 0 sinon
            {
                std::cout << 1 << " ";
            }
            else std::cout << 0 << " ";
            if(compos_connexes[i][j] && i!=j) ///Si i et j font partie d'une composante fortement connexe et que ce ne sont pas deux sommets confondus
                nb_compos++; ///On augmente le nombre de composantes fortement connexes de 1
        }
        std::cout << std::endl << std::endl;
    }
    std::cout << std::endl << "Il y a " << nb_compos << " composantes fortement connexes dans ce graphe." << std::endl; ///Affichage du nombre de composantes fortement connexes
    return compos_connexes;
}


bool* Graph::recherche_cmp(int i)
{
    bool* marquage = new bool[m_ordre]; ///Tableau de booléens qui dit si un sommet a été visité ou non
    bool* pred, *succ; ///Tableau de booléens pour dire si chaque sommet admet un prédecesseur (pred) ou un successeur (succ)
    bool* cmp = new bool[m_ordre];; ///Tableau de booléens pour dire si un sommet fait partie ou non de la composante fortement connexe retournée
    bool suivant=true; ///Booléen pour dire si il reste des sommets à visiter
    pred=new bool[m_ordre]; ///Allocation de mémoire pour les 3 tableaux
    succ=new bool[m_ordre];
    for(int j=0; j<m_ordre; j++) ///Initialisation des 3 tableaux
    {
        marquage[j]=false;
        pred[j]=false;
        succ[j]=false;
        cmp[j]=false;
    }
    pred[i]=true; ///On fait en sorte que notre sommet de départ admette un prédecesseur et un successeur
    succ[i]=true;
    while(suivant) ///Tant que tous les sommets n'ont pas été visités
    {
        suivant=false;
        for(int j=0; j<m_ordre; j++) ///Pour tout sommet j du graphe
        {
            if(!marquage[j] && pred[j]) ///Si il n'a pas été marqué et qu'il admet un prédecesseur
            {
                marquage[j]=true; ///Le sommet j a été visité
                for(int k=0; k<m_ordre; k++) ///Pout tout sommet k du graphe
                {
                    for(unsigned int l=0; l<m_vertices[j].m_out.size(); l++) ///Parmi les successeurs l de j
                    {
                        if(k==m_vertices[j].m_out[l] && !marquage[k]) ///Si k est un successeur de j et qu'il n'a pas été visité
                        {
                            pred[k]=true;///On dit que k a un prédecesseur (j)
                            succ[j]=true; ///On dit que j a un successeur[k]
                            suivant=true; ///Et on fait continuer la boucle
                        }
                    }
                }
            }
        }
    }
    for(int j=0; j<m_ordre; j++)
        cmp[j]=pred[j]&succ[j]; ///On met en place la composante fortement connexe.
    return cmp;
}